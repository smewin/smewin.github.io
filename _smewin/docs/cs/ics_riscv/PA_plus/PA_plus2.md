<style>p { text-indent: 2em; }</style>

# PA+ Lab2: Optimization

---

作者在 github 上翻阅 nemu 项目时，发现了一个[有趣的 PR ](https://github.com/NJU-ProjectN/nemu/pull/128)，或许可以秒杀这次实验（因为实验都差不多截止了，稍微多说一点应该也问题不大）

本次实验的关键点，实际就在于轮询和中断的不同处理逻辑。对于一些允许高频率请求的外设（如世界时间），轮询处理外设每次都需要进行读取和处理，这将会带来巨大的开销。如果改为中断式，每隔若干固定间隔后触发一个时钟中断，再去读取更新一次，就会显著减少其读取频率，大大解放机器的性能。

外设其实也遵循“局部性”（或者说，旱的旱死，涝的涝死），如果给到每个外设完全公平的读取间隔，你可以看到绝大部分的读取时间都被时钟占领了，因为每次读取时钟，都可以读到一个新的值，而其他的外设（比如键盘）可能并没有值需要读取，它们就会让出自己的处理时间。就像我们在测试软件 bug 时，如果给每个函数都插入一些调试信息，你会发现被反复请求的一些小函数会占领了绝大部分的调试信息。但这些函数往往由于被很多地方使用，反而是很难出现微小 bug 的地方（因为一直被调用，如果出现了 bug 就很容易被发现），导致真正的 bug 所在之处被海量的正常信息淹没。这也启示我们如何合理安排资源的分配，从而实现有效的权衡，达到一个相对好的总体效果。

!!! success "success"
    在你完成了这次 lab 后，你游玩马里奥的体验可能会有了质的变化。如果你实现了声卡，也会发现音乐的播放变得流畅了非常非常多。这也让我们明白，一个实现的高效或低效，对于常规的计算类程序而言可能就是多花点时间的事，但对于一个面向用户的服务类程序而言，效率所带来的用户体验优化可能是极其巨大的。一个程序的效率可能就决定了这个产品的生与死。

感谢 [github ID: snnbyyds](https://github.com/snnbyyds) 对本次实验灵感的贡献！