<style>p { text-indent: 2em; }</style>

# NEMU 代码导读

本节手册与计算机系统中的“基础软件”（gdb）一层有关。

```plaintext
----------
用户程序
----------
基础软件     gdb  ←  nemu
----------
操作系统
----------
硬件指令集
----------
```

!!! abstract "摘要"
    本篇文档将简要介绍 nemu 框架代码中的一些对新手而言较为生疏的点，从而便于实验的进行。

---

当你刚打开 nemu 代码时（假设你是使用 VSCode ），你估计会看到一对的头文件报红，和宏的报红。当你正确地配置好 includePath 之后，大部分的报红都会消失。

可见， nemu 的代码中大量使用了宏定义的方式来修改代码的逻辑，理解这些复杂宏的行为将会更有利于我们进行后续的实验，消除慌张感（不要紧张~）。


## 一些宏定义的解析

我们先来看看和当前实验进度（sdb）不太相关的一些宏。

### concat

我们先来到 `include/macro.h` 文件中，找到 `concat` 宏的定义。

```c
// macro concatenation
#define concat_temp(x, y) x ## y
#define concat(x, y) concat_temp(x, y)
#define concat3(x, y, z) concat(concat(x, y), z)
#define concat4(x, y, z, w) concat3(concat(x, y), z, w)
#define concat5(x, y, z, v, w) concat4(concat(x, y), z, v, w)
```
我们先看第一行， `concat_temp` 通过 `##` 运算符将两个参数连接起来，合成一个完整的单词。

然后，就开始嵌套定义了，我们就拥有了连接三个、四个、五个参数的 `concat` 宏。

这里，我们实际上就可以把宏视作一个函数，只是宏操作的“变量”是源文件中的字符串，而不是程序变量。

### ifdef/ifndef 与头文件保护

我们现在来到 `include/debug.h` 文件中，找到 `ifndef` ，从文件头直接跳到文件尾。

```c
#ifndef __DEBUG_H__
#define __DEBUG_H__
//......
#endif
```

这是在表达什么？

`#ifndef` 和 `#endif` 是成对的关系，意思是，如果没有定义过 `__DEBUG_H__` 这个宏，就把这对语句中间夹着的内容放到文件里，否则把中间的内容全部忽略掉。

但是，为什么要在 `#ifndef` 后紧跟对这个宏本身的定义呢？

我们想象一下一个情况，在一个 `struct.h` 文件中存在一个结构体的类型名称定义，这个头文件被两个不同的 .c 文件所 include ，然后我们生成可执行文件时，需要将这两个 .c 文件合到一起去。众所周知， `#include` 宏就是直接把一个文件中的内容原封不动地搬到 `#include` 所在的地方，这个宏在预处理时就原原本本地把两个 .c 文件中都展开了同一份 struct 的定义，然后你就出现了对一个类型重复定义的错误，文件无法编译通过。

但如果你加上这个 `#ifndef` 系列宏，在预处理时，在第一个 .c 文件中对 `#include <struct.h>` 展开时， `__DEBUG_H__` 暂未被定义，所以中间的内容会正常展开，实现对 `__DEBUG_H__` 和 `struct` 的定义。而在第二个 .c 文件中继续展开时，因为 `__DEBUG_H__` 已经被定义，头文件里面的所有内容都被删去，我们就成功编译通过了。

所以，这里面 `#ifndef` 宏的作用就是防止头文件的重复展开导致编译错误。

### Log

继续在 `include/debug.h` 文件中，看到 `Log` 宏，里面可以看到 `__FILE__` `__LINE__` `__func__` 这些宏，它们代表什么应该很清晰。

比较不清晰的可能就是宏定义上的 `...` 和定义末尾的 `## __VA_ARGS__` ，前面其他的宏已经说了那么多了，这个宏就请你去问 AI 吧~

---

前面讲解了几个简单的宏热热身，接下来我们要开始讲解和实验架构关系较为紧密的一些宏了。


### CPU_state

我们来到 `src/isa/riscv32/include/isa-def.h` 文件中，看到如下的结构体声明：

```c
typedef struct {
  word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)];
  vaddr_t pc;
} MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state);
```

这里面又嵌套了一个 `MUXDEF` 宏，可能不太好理解，我们换到另一个文件中对比着看。我们来到 `src/isa/x86/include/isa-def.h` （未正确实现版本）。

```c
// 暂未正确实现的 x86 寄存器结构体
typedef struct {
  struct {
    uint32_t _32;
    uint16_t _16;
    uint8_t _8[2];
  } gpr[8];

  /* Do NOT change the order of the GPRs' definitions. */
  uint32_t eax, ecx, edx, ebx, esp, ebp, esi, edi;

  vaddr_t pc;
} x86_CPU_state;
```

对比后可以看到，这里面的 `MUXDEF` 宏，最后会展开成类似 `riscv32_CPU_state` 的形式。

!!! question "eip 寄存器去了哪里"
    我们知道在 x86 架构中，存在一个 `eip` 寄存器，就是起到 PC 的作用，但是为什么 `x86_CPU_state` 这个结构体中不去声明 `eip` ，而是在结构体中声明一个 `pc` 呢？

我们来到 `include/isa.h` 中，看到：

```c
// The macro `__GUEST_ISA__` is defined in $(CFLAGS).
// It will be expanded as "x86" or "mips32" ...
typedef concat(__GUEST_ISA__, _CPU_state) CPU_state;
```

这里用到了我们前面讲过的 `concat` 宏，将 `__GUEST_ISA__` 和 `_CPU_state` 连接起来，得到 `x86_CPU_state` 或者 `riscv32_CPU_state` 这样的结构体名称，并给到它一个别名 `CPU_state`。

所以，`__GUEST_ISA__` 宏的作用就是根据当前的配置，选择一个 ISA ，并将 `CPU_state` 结构体名称指向它。这个宏的来源就是 make 时的配置文件。

然后我们现在来到 `src/cpu/cpu-exec.c` 文件中，就可以看到 `CPU_state` 变量的声明了。

```c
CPU_state cpu = {};
```

在 `src/isa/riscv32/init.c` 中，我们可以看到它对 `CPU_state` 结构体的初始化。

```c
static void restart() {
  /* Set the initial program counter. */
  cpu.pc = RESET_VECTOR;

  /* The zero register is always 0. */
  cpu.gpr[0] = 0;
}
```

很不错，完美符合我们前面的结构体架构。

!!! success "成功的开始"
    代码框架中还有其他很多的宏，限于篇幅我们不可能一一讲解，但相信对这几个最关键的宏的讲解已经让你建立了最初的信心，能够尽力去理解这些宏的作用。

    你可能也感受到了，任何一个声明可能都会跨好几个文件被使用，这体现了好好配置项目结构，消除报红，实现声明跳转的必要性。

## nemu 对指令集的抽象

NEMU_STATE, decode s,

## gdb 式的框架

